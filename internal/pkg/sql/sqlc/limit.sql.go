// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: limit.sql

package db

import (
	"context"
)

const createLimit = `-- name: CreateLimit :one
insert into limits
(tier_id, action, value)
values ($1, $2, $3)
returning tier_id, action, value
`

type CreateLimitParams struct {
	TierID int16  `json:"tier_id"`
	Action string `json:"action"`
	Value  int32  `json:"value"`
}

func (q *Queries) CreateLimit(ctx context.Context, arg *CreateLimitParams) (*Limit, error) {
	row := q.queryRow(ctx, q.createLimitStmt, createLimit, arg.TierID, arg.Action, arg.Value)
	var i Limit
	err := row.Scan(&i.TierID, &i.Action, &i.Value)
	return &i, err
}

const deleteLimit = `-- name: DeleteLimit :exec
delete from limits where tier_id = $1 and action = $2
`

type DeleteLimitParams struct {
	TierID int16  `json:"tier_id"`
	Action string `json:"action"`
}

func (q *Queries) DeleteLimit(ctx context.Context, arg *DeleteLimitParams) error {
	_, err := q.exec(ctx, q.deleteLimitStmt, deleteLimit, arg.TierID, arg.Action)
	return err
}

const getLimit = `-- name: GetLimit :one
select tier_id, action, value
from limits
where tier_id = $1 and action = $2
limit 1
`

type GetLimitParams struct {
	TierID int16  `json:"tier_id"`
	Action string `json:"action"`
}

func (q *Queries) GetLimit(ctx context.Context, arg *GetLimitParams) (*Limit, error) {
	row := q.queryRow(ctx, q.getLimitStmt, getLimit, arg.TierID, arg.Action)
	var i Limit
	err := row.Scan(&i.TierID, &i.Action, &i.Value)
	return &i, err
}

const listLimits = `-- name: ListLimits :many
select tier_id, action, value
from limits
limit $1 offset $2
`

type ListLimitsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListLimits(ctx context.Context, arg *ListLimitsParams) ([]*Limit, error) {
	rows, err := q.query(ctx, q.listLimitsStmt, listLimits, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Limit{}
	for rows.Next() {
		var i Limit
		if err := rows.Scan(&i.TierID, &i.Action, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
