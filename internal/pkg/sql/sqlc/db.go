// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0

package db

import (
	"context"
	"database/sql"
	"fmt"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
	if q.assignTaskStmt, err = db.PrepareContext(ctx, assignTask); err != nil {
		return nil, fmt.Errorf("error preparing query AssignTask: %w", err)
	}
	if q.countTaskByAssigneeTodayStmt, err = db.PrepareContext(ctx, countTaskByAssigneeToday); err != nil {
		return nil, fmt.Errorf("error preparing query CountTaskByAssigneeToday: %w", err)
	}
	if q.createLimitStmt, err = db.PrepareContext(ctx, createLimit); err != nil {
		return nil, fmt.Errorf("error preparing query CreateLimit: %w", err)
	}
	if q.createTaskStmt, err = db.PrepareContext(ctx, createTask); err != nil {
		return nil, fmt.Errorf("error preparing query CreateTask: %w", err)
	}
	if q.createTierStmt, err = db.PrepareContext(ctx, createTier); err != nil {
		return nil, fmt.Errorf("error preparing query CreateTier: %w", err)
	}
	if q.createUserStmt, err = db.PrepareContext(ctx, createUser); err != nil {
		return nil, fmt.Errorf("error preparing query CreateUser: %w", err)
	}
	if q.deleteLimitStmt, err = db.PrepareContext(ctx, deleteLimit); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteLimit: %w", err)
	}
	if q.deleteTaskStmt, err = db.PrepareContext(ctx, deleteTask); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteTask: %w", err)
	}
	if q.deleteTierStmt, err = db.PrepareContext(ctx, deleteTier); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteTier: %w", err)
	}
	if q.deleteUserStmt, err = db.PrepareContext(ctx, deleteUser); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteUser: %w", err)
	}
	if q.getLimitStmt, err = db.PrepareContext(ctx, getLimit); err != nil {
		return nil, fmt.Errorf("error preparing query GetLimit: %w", err)
	}
	if q.getTaskStmt, err = db.PrepareContext(ctx, getTask); err != nil {
		return nil, fmt.Errorf("error preparing query GetTask: %w", err)
	}
	if q.getTierStmt, err = db.PrepareContext(ctx, getTier); err != nil {
		return nil, fmt.Errorf("error preparing query GetTier: %w", err)
	}
	if q.getUserByNameStmt, err = db.PrepareContext(ctx, getUserByName); err != nil {
		return nil, fmt.Errorf("error preparing query GetUserByName: %w", err)
	}
	if q.listLimitsStmt, err = db.PrepareContext(ctx, listLimits); err != nil {
		return nil, fmt.Errorf("error preparing query ListLimits: %w", err)
	}
	if q.listTasksStmt, err = db.PrepareContext(ctx, listTasks); err != nil {
		return nil, fmt.Errorf("error preparing query ListTasks: %w", err)
	}
	if q.listTiersStmt, err = db.PrepareContext(ctx, listTiers); err != nil {
		return nil, fmt.Errorf("error preparing query ListTiers: %w", err)
	}
	if q.listUsersStmt, err = db.PrepareContext(ctx, listUsers); err != nil {
		return nil, fmt.Errorf("error preparing query ListUsers: %w", err)
	}
	if q.updateUserTierStmt, err = db.PrepareContext(ctx, updateUserTier); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateUserTier: %w", err)
	}
	return &q, nil
}

func (q *Queries) Close() error {
	var err error
	if q.assignTaskStmt != nil {
		if cerr := q.assignTaskStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing assignTaskStmt: %w", cerr)
		}
	}
	if q.countTaskByAssigneeTodayStmt != nil {
		if cerr := q.countTaskByAssigneeTodayStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing countTaskByAssigneeTodayStmt: %w", cerr)
		}
	}
	if q.createLimitStmt != nil {
		if cerr := q.createLimitStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createLimitStmt: %w", cerr)
		}
	}
	if q.createTaskStmt != nil {
		if cerr := q.createTaskStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createTaskStmt: %w", cerr)
		}
	}
	if q.createTierStmt != nil {
		if cerr := q.createTierStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createTierStmt: %w", cerr)
		}
	}
	if q.createUserStmt != nil {
		if cerr := q.createUserStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createUserStmt: %w", cerr)
		}
	}
	if q.deleteLimitStmt != nil {
		if cerr := q.deleteLimitStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteLimitStmt: %w", cerr)
		}
	}
	if q.deleteTaskStmt != nil {
		if cerr := q.deleteTaskStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteTaskStmt: %w", cerr)
		}
	}
	if q.deleteTierStmt != nil {
		if cerr := q.deleteTierStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteTierStmt: %w", cerr)
		}
	}
	if q.deleteUserStmt != nil {
		if cerr := q.deleteUserStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteUserStmt: %w", cerr)
		}
	}
	if q.getLimitStmt != nil {
		if cerr := q.getLimitStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getLimitStmt: %w", cerr)
		}
	}
	if q.getTaskStmt != nil {
		if cerr := q.getTaskStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getTaskStmt: %w", cerr)
		}
	}
	if q.getTierStmt != nil {
		if cerr := q.getTierStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getTierStmt: %w", cerr)
		}
	}
	if q.getUserByNameStmt != nil {
		if cerr := q.getUserByNameStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getUserByNameStmt: %w", cerr)
		}
	}
	if q.listLimitsStmt != nil {
		if cerr := q.listLimitsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listLimitsStmt: %w", cerr)
		}
	}
	if q.listTasksStmt != nil {
		if cerr := q.listTasksStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listTasksStmt: %w", cerr)
		}
	}
	if q.listTiersStmt != nil {
		if cerr := q.listTiersStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listTiersStmt: %w", cerr)
		}
	}
	if q.listUsersStmt != nil {
		if cerr := q.listUsersStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listUsersStmt: %w", cerr)
		}
	}
	if q.updateUserTierStmt != nil {
		if cerr := q.updateUserTierStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateUserTierStmt: %w", cerr)
		}
	}
	return err
}

func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type Queries struct {
	db                           DBTX
	tx                           *sql.Tx
	assignTaskStmt               *sql.Stmt
	countTaskByAssigneeTodayStmt *sql.Stmt
	createLimitStmt              *sql.Stmt
	createTaskStmt               *sql.Stmt
	createTierStmt               *sql.Stmt
	createUserStmt               *sql.Stmt
	deleteLimitStmt              *sql.Stmt
	deleteTaskStmt               *sql.Stmt
	deleteTierStmt               *sql.Stmt
	deleteUserStmt               *sql.Stmt
	getLimitStmt                 *sql.Stmt
	getTaskStmt                  *sql.Stmt
	getTierStmt                  *sql.Stmt
	getUserByNameStmt            *sql.Stmt
	listLimitsStmt               *sql.Stmt
	listTasksStmt                *sql.Stmt
	listTiersStmt                *sql.Stmt
	listUsersStmt                *sql.Stmt
	updateUserTierStmt           *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db:                           tx,
		tx:                           tx,
		assignTaskStmt:               q.assignTaskStmt,
		countTaskByAssigneeTodayStmt: q.countTaskByAssigneeTodayStmt,
		createLimitStmt:              q.createLimitStmt,
		createTaskStmt:               q.createTaskStmt,
		createTierStmt:               q.createTierStmt,
		createUserStmt:               q.createUserStmt,
		deleteLimitStmt:              q.deleteLimitStmt,
		deleteTaskStmt:               q.deleteTaskStmt,
		deleteTierStmt:               q.deleteTierStmt,
		deleteUserStmt:               q.deleteUserStmt,
		getLimitStmt:                 q.getLimitStmt,
		getTaskStmt:                  q.getTaskStmt,
		getTierStmt:                  q.getTierStmt,
		getUserByNameStmt:            q.getUserByNameStmt,
		listLimitsStmt:               q.listLimitsStmt,
		listTasksStmt:                q.listTasksStmt,
		listTiersStmt:                q.listTiersStmt,
		listUsersStmt:                q.listUsersStmt,
		updateUserTierStmt:           q.updateUserTierStmt,
	}
}
